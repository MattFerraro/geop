use core::slice::SlicePattern;
use std::{rc::Rc, vec, slice::Iter};

use geop_geometry::{points::point::Point, surfaces::surface::Surface};

use crate::topology::vertex::Vertex;

use super::{edge::{Edge, self, EdgeIntersection, Direction}, face::Face};

#[derive(Debug, Clone)]
pub struct EdgeLoop {
    pub edges: Vec<Rc<Edge>>,
}

// A line can be In, On, or Out of an edge loop.
pub enum EdgeLoopIntersection {
    CrossingVertex(Vertex), // crossing
    TouchingVertex(Vertex), // crossing
    // CrossingEdge(Edge), // touching, Touching Edge will be considered as two crossing points
    // TouchingEdge(Edge), // touching, Crossing Edge will be considered as three crossing points
}


// An EdgeLoop is a closed loop of edges which is not self intersecting (because otherwise project would not be defined for self intersection point).
// It has a defined inside and outside, which is determined by the direction of the edges.
impl EdgeLoop {
    pub fn new(edges: Vec<Rc<Edge>>) -> EdgeLoop {
        for i in 0..edges.len() {
            let edge = edges[i].clone();
            let next_edge = edges[(i + 1) % edges.len()].clone();
            assert!(edge.end == next_edge.start);
        }
        assert!(edges.len() > 0);
        assert!(edges[0].start == edges[edges.len() - 1].end);
        EdgeLoop { edges }
    }

    pub fn contains(&self, point: &Point) -> bool {
        return self.get_edge_index(point).is_some();
    }

    fn get_edge_index(&self, point: &Point) -> Option<usize> {
        for (i, edge) in self.edges.iter().enumerate() {
            if edge.contains(point) {
                return Some(i);
            }
        }
        None
    }

    // Gets the subcurve between these two points
    pub fn get_subcurve(&self, start: Vertex, end: Vertex) -> Vec<Rc<Edge>> {
        let mut result = Vec::<Rc<Edge>>::new();
        let mut start_i = self
            .get_edge_index(&start.point)
            .expect("Start point has to be on edge");
        let mut end_edge = self
            .get_edge_index(&end.point)
            .expect("End point has to be on edge");

        if start_i == end_edge {
            let edge = Rc::new(Edge::new(start, end, self.edges[start_i].curve, self.edges[start_i].direction));
            result.push(edge);
        }

        let mut edge = self.edges[start_i];
        result.push(Rc::new(Edge::new(start, edge.end, edge.curve, edge.direction)));
        for i in start_i + 1..end_edge {
            edge = self.edges[i % self.edges.len()];
            result.push(edge.clone());
        }
        let mut edge = self.edges[end_edge % self.edges.len()];
        result.push(Rc::new(Edge::new(edge.start, end, edge.curve, edge.direction)));
        result
    }

    pub fn get_subcurves(&self, vertices: Vec<(Vertex, Vertex)>) -> Vec<Vec<Rc<Edge>>> {
        let mut result = Vec::<Vec<Rc<Edge>>>::new();
        for (seg_start, seg_end) in vertices.iter() {
            let segment = self.get_subcurve(seg_start.clone(), seg_end.clone());            
            result.push(segment);
        }
        result
    }

    pub fn intersect(&self, other: &EdgeLoop) -> Vec<Vertex> {
        let mut intersections = Vec::<Vertex>::new();
        for edge_self in self.edges.iter() {
            for edge_other in other.edges.iter() {
                let edge_intersections = edge_self.intersections(edge_other);
                for edge_intersection in edge_intersections {
                    match edge_intersection {
                        EdgeIntersection::Vertex(vertex) => {
                            if !intersections.contains(&vertex) {
                                intersections.push(vertex);
                            }
                        },
                        EdgeIntersection::Edge(edge) => {
                            if !intersections.contains(&edge.start) {
                                intersections.push(edge.start);
                            }
                            if !intersections.contains(&edge.end) {
                                intersections.push(edge.end);
                            }
                        },
                    }
                }
            }
        }

        intersections
    }


    // Takes 2 EdgeLoops and connects them at intersecting points with new vertices.
    // If there are overlapping edges, there will be a vertex for the beginning and the end of the overlapping edges, and a connecting edge for each loop.
    // If there are no intersections, the outer vector will have length 1.
    fn split(&self, other: &EdgeLoop) -> Option<(EdgeLoop, EdgeLoop)> {
        // First, find all intersections and order them by position on the edge loop.
        let mut split_verts: Vec<Vertex> = self.intersect(other);

        // Due to the properties of edge loops, the edges intersecting the other edge loop can be generated by zipping two following vertices.
        let n: usize = split_verts.len();
        assert!(n % 2 == 0);
        if n == 0 {
            return None;
        }

        let mut split_verts_self: Vec<(f64, Vertex)> = Vec::new();
        let mut split_verts_other: Vec<(f64, Vertex)> = Vec::new();
        for vert in split_verts.iter() {
            split_verts_self.push((
                self.project(&vert.point)
                    .expect("Intersection point has to be on edge"),
                vert.clone(),
            ));
            split_verts_other.push((
                other
                    .project(&vert.point)
                    .expect("Intersection point has to be on edge"),
                vert.clone(),
            ));
        }
        split_verts_self.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
        split_verts_other.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());

        let mut segments_self = Vec::with_capacity(n);
        for i in 0..n {
            let start_vert = split_verts_self[i].1.clone();
            let end_vert = split_verts_self[(i + 1) % n].1.clone();
            let edge_self = self
                .get_subcurve(start_vert, end_vert)
                .expect("Intersection points have to be on edge");
            segments_self.push(edge_self);
        }

        let mut segments_other = Vec::with_capacity(n);
        for i in 0..n {
            let start_vert = split_verts_other[i].1.clone();
            let end_vert = split_verts_other[(i + 1) % n].1.clone();
            let edge_other = other
                .get_subcurve(start_vert, end_vert)
                .expect("Intersection points have to be on edge");
            segments_other.push(edge_other);
        }

        Some((segments_self, segments_other))
    }

    // Splits this edge loop with another edge loop.
    // This makes sure that the resulting edge loops are closed and do not intersect each other anymore.
    // Neighbouring edge loops will share the same end points for the edges, and the two neighbouring edges will face opposite direction.
    // If edge loops are not overlapping, the result will be two edge loops.
    pub fn remesh(&self, other: &EdgeLoop) -> Vec<EdgeLoop> {
        let (mut segments_self, mut segments_other) = self.split(other)?;
        for segment in segments_self.iter() {
            println!("New segment self");
            for edge in segment.iter() {
                println!("Edge: {:?} - {:?}", edge.start.point, edge.end.point);
            }
        }

        for segment in segments_other.iter() {
            println!("New segment other");
            for edge in segment.iter() {
                println!("Edge: {:?} - {:?}", edge.start.point, edge.end.point);
            }
        }

        let mut edge_loops = Vec::new();
        let mut next_segment_is_self = false;
        while let Some(mut next_segment) = segments_self.pop().or_else(|| segments_other.pop()) {
            let mut edge_loop: Vec<Rc<Edge>> = next_segment.drain(..).collect();
            while edge_loop.len() == 0 || edge_loop[edge_loop.len() - 1].end != edge_loop[0].start {
                let relevant_segments = if next_segment_is_self {
                    &mut segments_self
                } else {
                    &mut segments_other
                };
                for (i, segment) in relevant_segments.iter().enumerate() {
                    if segment[0].start == edge_loop[edge_loop.len() - 1].end {
                        next_segment = relevant_segments.remove(i);
                        break;
                    }
                }
                edge_loop.extend(next_segment.drain(..));
                next_segment_is_self = !next_segment_is_self;
            }
            edge_loops.push(EdgeLoop::new(edge_loop));
        }
        Some(edge_loops)
    }

    pub fn remesh_multiple(&self, other: &[EdgeLoop]) -> Option<Vec<EdgeLoop>> {
        let mut result = vec![self.clone()];
        
        for other_edge_loop in other {
            let mut new_result = Vec::<EdgeLoop>::new();
            for edge_loop in result {
                let mut new_edge_loops = edge_loop.remesh(other_edge_loop);
                new_result.extend(new_edge_loops.drain(..));
            }
            result = new_result;
        }

        Some(result)
    }

    pub fn neg(&self) -> EdgeLoop {
        todo!()
    }

    // // If no intersection is there, the result is None. Otherwise we can be sure that the result is a single edge loop.
    // pub fn union(&self, other: &EdgeLoop) -> Option<EdgeLoop> {
    //     let mut edge_loops = self.remesh_self_other(other)?;

    //     // Find an outer vertex
    //     let mut outer_edge = &edge_loops[0].edges[0];
    //     for edge_loop in edge_loops.iter() {
    //         for edge in edge_loop.edges.iter() {

    //             match edge.start.point.x.partial_cmp(&outer_edge.start.point.x) {
    //                 Some(std::cmp::Ordering::Less) => {
    //                     outer_edge = edge;
    //                 },
    //                 _ => {
    //                     match edge.start.point.y.partial_cmp(&outer_edge.start.point.y) {
    //                         Some(std::cmp::Ordering::Less) => {
    //                             outer_edge = edge;
    //                         },
    //                         _ => {
    //                             match edge.start.point.z.partial_cmp(&outer_edge.start.point.z) {
    //                                 Some(std::cmp::Ordering::Less) => {
    //                                     outer_edge = edge;
    //                                 },
    //                                 _ => {}
    //                             }
    //                         }
    //                     }
    //                 }
    //             };
    //         }
    //     }

    //     // Find the edge loop which contain the outer vertex.
    //     let outer_edge_loop_index = edge_loops.iter().position(|edge_loop| edge_loop.edges.contains(&outer_edge)).unwrap();

    //     Some(edge_loops.swap_remove(outer_edge_loop_index))
    // }
}

pub fn remesh_multiple_multiple(edge_loops_self: &[EdgeLoop], edge_loops_other: &[EdgeLoop]) -> Vec<EdgeLoop> {
    let mut result = Vec::from(edge_loops_self);
    
    for other_edge_loop in edge_loops_other {
        let mut new_result = Vec::<EdgeLoop>::new();
        let mut new_edge_loops = other_edge_loop.remesh_multiple(result.as_slice());
        result = new_result;
    }

    result
}
